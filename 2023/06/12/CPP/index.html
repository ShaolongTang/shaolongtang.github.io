<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    Hexo
  </title>
  <meta name="description" content="">
  
  <meta name="keywords" content="
  
  ">
  
  <meta name="author" content="John Doe">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/shaolongtang/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
<meta name="generator" content="Hexo 7.2.0"></head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/shaolongtang/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/shaolongtang/">Archives</a></li>
        
        
        <li><a href="/shaolongtang/">Categories</a></li>
        
        
        <li><a href="/shaolongtang/">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/shaolongtang/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/shaolongtang/" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/shaolongtang/"
           class="header-toolbar-right"> 2 </a>
      </li>
      <li>
        <a href="/shaolongtang/" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/shaolongtang/"
           class="header-toolbar-right"> 0 </a>
      </li>
      <li>
        <a href="/shaolongtang/" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/shaolongtang/"
           class="header-toolbar-right"> 0 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/shaolongtang/">Hexo</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    John Doe

    <span class="post-date float-right" title="{{moment(1686539143329).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1686539143329).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>Untitle</h1>
    <h1 id="c-常见框架"><a href="#c-常见框架" class="headerlink" title="c++常见框架"></a>c++常见框架</h1><h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><p>冒泡、插入、选择、桶、归并、快速、希尔排序。默认从小到大排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡：依次比较相邻的两个数，若前面的大于后面的，则交换这两个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入：假设前面的数已经有序，将当前的数插入到前面已经有序的数列中，找到一个合适位置，合适位置之前不动，合适位置之后的都往后移动一个位置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//选择：每次从剩下的数中选择一个最小的放到当前的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//桶排序：利用数组下标排序：根据数据范围建立桶、统计每个数出现的次数、打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//归并：先分解再合并，对半分开，分解到每个部分只有一个数；合并：将两个有序的序列合并成一个新的有序序列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序：每次选取一个基准数key,让key之前的都比key小，key之后的都比key大，利用插空填数法；分成了两个部分，在每个部分继续快速排序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//希尔排序：设置一个步长d=n,每次间隔d个数进行插入排序，d每次减半直到1。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-高精度"><a href="#2-高精度" class="headerlink" title="2.高精度"></a>2.高精度</h2><p>基本数据类型在计算时精度不够，利用字符串保存数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//+ 对应位置相加，之后处理进位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//- 对应位置相减，不够减借位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*	c[i+k]+=a[i]*b[k],之后对数组c处理进位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /&amp;%	高进度/低精度，p=p*10+a[i]  p为余数，开始为0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-二分-分治"><a href="#3-二分-分治" class="headerlink" title="3.二分&amp;分治"></a>3.二分&amp;分治</h2><p>二分：把一个问题一分为二，通常用来找一个东西，二分的前提是有序。</p>
<p>分治：把一个问题分解成多个小问题来求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left=<span class="number">1</span>,right=n;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">  	<span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">  	<span class="keyword">if</span>(<span class="built_in">f</span>(mid)==x)&#123;</span><br><span class="line">      	结果相关</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">f</span>(mid)&gt;x)&#123;<span class="comment">//说明大了，在左边找，改变right</span></span><br><span class="line">      	right=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">else</span>&#123;<span class="comment">//说明小了，在右边找，改变left</span></span><br><span class="line">      	left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;left <span class="keyword">or</span> right相关的;</span><br><span class="line"><span class="comment">//二分 找数 http://noi.openjudge.cn/ch0111/01/</span></span><br><span class="line"><span class="comment">//二分 求平方根</span></span><br><span class="line"><span class="comment">//二分 木材加工</span></span><br><span class="line"><span class="comment">//二分 解方程 http://noi.openjudge.cn/ch0204/7891/</span></span><br><span class="line"><span class="comment">//二分 填报大学 https://cspoj.com/problem.php?id=1899</span></span><br><span class="line"><span class="comment">//二分 砍树 https://cspoj.com/problem.php?id=1908</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治</span></span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="comment">//归并排序-逆序对</span></span><br><span class="line"><span class="comment">//循环比赛日程表</span></span><br><span class="line"><span class="comment">//取余运算</span></span><br><span class="line"><span class="comment">//黑白棋子的移动</span></span><br><span class="line"><span class="comment">//麦森数-快速幂</span></span><br></pre></td></tr></table></figure>

<h2 id="4-递推"><a href="#4-递推" class="headerlink" title="4.递推"></a>4.递推</h2><p>递推：由已知推出未知，通常是设数组、找关系、循环求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//斐波那契数列 走楼梯 铺地砖 蜜蜂路线 https://cspoj.com/problem.php?id=1368</span></span><br><span class="line"><span class="comment">//昆虫繁殖</span></span><br><span class="line"><span class="comment">//数字三角形</span></span><br><span class="line"><span class="comment">//位数问题</span></span><br><span class="line"><span class="comment">//过河卒 https://cspoj.com/problem.php?id=1224</span></span><br><span class="line"><span class="comment">//流感传染</span></span><br></pre></td></tr></table></figure>

<h2 id="5-贪心"><a href="#5-贪心" class="headerlink" title="5.贪心"></a>5.贪心</h2><p>将大问题分解成多个小问题，每个小问题都求最优解，最终导致大问题的最优解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排队打水-接水时间少的先</span></span><br><span class="line"><span class="comment">//均分纸牌</span></span><br><span class="line"><span class="comment">//删数问题-递增去最后一个，递减去第一个</span></span><br><span class="line"><span class="comment">//拦截导弹-有多套系统可以用，用高度最低的</span></span><br><span class="line"><span class="comment">//活动选择-结束时间早的优先</span></span><br><span class="line"><span class="comment">//最大整数-大的字符串在前面</span></span><br><span class="line"><span class="comment">//纪念品分组-大的和小的在一组</span></span><br><span class="line"><span class="comment">//合并果子（霍夫曼编码）-每次合并两个最小的</span></span><br><span class="line"><span class="comment">//金银岛-选性价比高的</span></span><br><span class="line"><span class="comment">//书架-选高度高的奶牛</span></span><br></pre></td></tr></table></figure>

<h2 id="6-深度优先搜索dfs"><a href="#6-深度优先搜索dfs" class="headerlink" title="6.深度优先搜索dfs"></a>6.深度优先搜索dfs</h2><p>基本思想：从起点出发，有多个选择可以选择时，选择其中一个走下去，直到目的地，走不通则返回上一步。</p>
<h3 id="6-1-迷宫问题"><a href="#6-1-迷宫问题" class="headerlink" title="6.1:迷宫问题"></a>6.1:迷宫问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">if</span>(目的地)&#123;</span><br><span class="line">      	结果相关<span class="comment">//打印、找最小值、判断能不能到</span></span><br><span class="line">    &#125;</span><br><span class="line">  	<span class="keyword">else</span>&#123;</span><br><span class="line">      	<span class="keyword">for</span>(各种选择)&#123;</span><br><span class="line">          	新的点</span><br><span class="line">            <span class="keyword">if</span>(条件)&#123;	<span class="comment">//坐标在合理范围、可以走、没有被走过</span></span><br><span class="line">              	标记</span><br><span class="line">                保存结果</span><br><span class="line">                <span class="built_in">dfs</span>(k+<span class="number">1</span>)</span><br><span class="line">                取消标记</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迷宫问题</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-排列问题"><a href="#6-2-排列问题" class="headerlink" title="6.2:排列问题"></a>6.2:排列问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(各种选择)&#123;</span><br><span class="line">				<span class="keyword">if</span>(条件)&#123;</span><br><span class="line">						标记</span><br><span class="line">						保存结果</span><br><span class="line">						<span class="keyword">if</span>(目的地)&#123;</span><br><span class="line">								结果相关</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span>&#123;</span><br><span class="line">								<span class="built_in">dfs</span>(k+<span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						取消标记</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//素数环</span></span><br><span class="line"><span class="comment">//n选m排列</span></span><br><span class="line"><span class="comment">//数字拆分</span></span><br><span class="line"><span class="comment">//八皇后问题</span></span><br><span class="line"><span class="comment">//工作分配</span></span><br><span class="line"><span class="comment">//选书</span></span><br><span class="line"><span class="comment">//马走日</span></span><br><span class="line"><span class="comment">//有重复元素的排列</span></span><br></pre></td></tr></table></figure>

<h2 id="7-广度优先搜索bfs"><a href="#7-广度优先搜索bfs" class="headerlink" title="7.广度优先搜索bfs"></a>7.广度优先搜索bfs</h2><p>基本思想：从起点出发，从内到外，逐层遍历，直到目的地。第一次找到就是最短的。</p>
<p>队列：先进先出			栈：先进后出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">p.<span class="built_in">push</span>(a);		<span class="comment">//入队，放入队尾</span></span><br><span class="line">p.<span class="built_in">front</span>();		<span class="comment">//获取队首元素</span></span><br><span class="line">p.<span class="built_in">pop</span>();			<span class="comment">//将队首去掉</span></span><br><span class="line">p.<span class="built_in">back</span>();			<span class="comment">//获取队尾</span></span><br><span class="line">p.<span class="built_in">size</span>();			<span class="comment">//队列长度</span></span><br><span class="line">p.<span class="built_in">empty</span>();		<span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure>

<p>bfs 框架</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	初始化(起点入队)</span><br><span class="line">    <span class="keyword">while</span>(队列非空)&#123;</span><br><span class="line">      	p.<span class="built_in">front</span>();</span><br><span class="line">      	p.<span class="built_in">pop</span>();</span><br><span class="line">      	<span class="keyword">for</span>(各种选择)&#123;</span><br><span class="line">          	新的点</span><br><span class="line">            <span class="keyword">if</span>(条件)&#123;</span><br><span class="line">              	标记</span><br><span class="line">                保存结果</span><br><span class="line">                入队</span><br><span class="line">                <span class="keyword">if</span>(目的地)&#123;</span><br><span class="line">                  	结果相关</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迷宫问题 营救 献给阿尔吉侬的花束 仙岛求药</span></span><br><span class="line"><span class="comment">//红与黑</span></span><br><span class="line"><span class="comment">//城市路线</span></span><br><span class="line"><span class="comment">//细胞</span></span><br><span class="line"><span class="comment">//面积</span></span><br><span class="line"><span class="comment">//最少转弯问题</span></span><br></pre></td></tr></table></figure>

<h2 id="8-动态规划"><a href="#8-动态规划" class="headerlink" title="8.动态规划"></a>8.动态规划</h2><p>将大问题分解成多个阶段，在每个阶段进行决策，决策依赖于之前的状态，会对之后的决策产生影响，最终结果最优。通常用在max min问题中。</p>
<p>四步走</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>设数组<span class="built_in">f</span>(一维、二维、三维)</span><br><span class="line"><span class="number">2.</span>理解数组的含义</span><br><span class="line"><span class="number">3.</span>寻找状态转移方程（关键在于i的选择与否）</span><br><span class="line"><span class="number">4.</span>循环求解</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字三角形</span></span><br><span class="line"><span class="comment">//最长上升子序列 拦截导弹 友好城市 登山 LIS</span></span><br><span class="line"><span class="comment">//最大上升子序列和</span></span><br><span class="line"><span class="comment">//最长公共子序列 LCS</span></span><br><span class="line"><span class="comment">//机器分配</span></span><br><span class="line"><span class="comment">//挖地雷</span></span><br></pre></td></tr></table></figure>

<h3 id="8-1最长上升子序列-LIS-不连续–数组"><a href="#8-1最长上升子序列-LIS-不连续–数组" class="headerlink" title="8.1最长上升子序列 LIS 不连续–数组"></a>8.1最长上升子序列 LIS 不连续–数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题描述：找到最长的n个数字中不连续的上升的序列。</span><br><span class="line">in:<span class="number">1</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">4</span> <span class="number">8</span>	out:<span class="number">4</span></span><br><span class="line">  </span><br><span class="line">数组设置：f[i]:以第i个数结尾的LIS的长度，f[<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">基本思想：去前面找一个高度低中的最大值加一</span><br><span class="line">f[i]=<span class="built_in">max</span>(f[k])+<span class="number">1</span>		a[k]&lt;a[i],k的范围：<span class="number">1</span>至i<span class="number">-1</span></span><br><span class="line">结果：<span class="built_in">max</span>(f[<span class="number">1</span>,...n])</span><br></pre></td></tr></table></figure>

<h3 id="8-2-最大字段和连续–数组"><a href="#8-2-最大字段和连续–数组" class="headerlink" title="8.2 最大字段和连续–数组"></a>8.2 最大字段和连续–数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题描述：n个整数（包含负整数）组成的序列a1,a2,…,an，求该序列子段和的最大值。当所有整数均为负值时定义其最大子段和为<span class="number">0</span>。</span><br><span class="line">in:<span class="number">-2</span>,<span class="number">11</span>,<span class="number">-4</span>,<span class="number">13</span>,<span class="number">-5</span>,<span class="number">-2</span>	out:<span class="number">11</span><span class="number">-4</span>+<span class="number">13</span>=<span class="number">20</span></span><br><span class="line">  </span><br><span class="line">数组设置：f[i]:从a1到<span class="built_in">ai</span>(前i项)中，包含ai的最大的子段和，f[<span class="number">1</span>]=a1</span><br><span class="line">基本思想：前一个f小于<span class="number">0</span>,则为自己。</span><br><span class="line">f[i]=<span class="built_in">max</span>(f[i<span class="number">-1</span>]+a[i],a[i]) </span><br><span class="line">结果：<span class="built_in">max</span>(f[<span class="number">1</span>,...n])</span><br></pre></td></tr></table></figure>

<h3 id="8-3最长公共子序列-矩阵类型"><a href="#8-3最长公共子序列-矩阵类型" class="headerlink" title="8.3最长公共子序列-矩阵类型"></a>8.3最长公共子序列-矩阵类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目描述：查找两个字符串a,b中的最长公共子串。若有多个，输出在较短串中最先出现的那个。</span><br><span class="line">in:</span><br><span class="line">abcdefghijklmnop</span><br><span class="line">abcsafjklmnopqrstuvw</span><br><span class="line">out:</span><br><span class="line">长度为<span class="number">7</span>，(jklmnop)</span><br><span class="line"></span><br><span class="line">数组设置：f[i][k]:数组a的前i个字符中、数组b的前k个字符中最长公共字符串的长度。f[i][<span class="number">0</span>]=<span class="number">0</span>,f[<span class="number">0</span>][k]=<span class="number">0</span></span><br><span class="line">基本思想：相同就向前推一个，不相同就两个里面找个少的。</span><br><span class="line">f[i][k]=(f[i<span class="number">-1</span>][k<span class="number">-1</span>]+<span class="number">1</span>,f[i<span class="number">-1</span>][k],f[i][k<span class="number">-1</span>]),前一个是a[i]=b[k]的情况，后面两个是不相等的情况。</span><br><span class="line">结果：f[n][m]</span><br></pre></td></tr></table></figure>

<h3 id="8-4字符串编辑距离-矩阵类型"><a href="#8-4字符串编辑距离-矩阵类型" class="headerlink" title="8.4字符串编辑距离-矩阵类型"></a>8.4字符串编辑距离-矩阵类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">题目描述：对于两个不同的字符串，我们有一套操作方法来把他们变得相同，具体方法为：修改一个字符（如把“a”替换为“b”）。删除一个字符（如把“traveling”变为“travelng”）。对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。无论增加还是减少“g”，我们都仅仅需要一次操作。我们把这个操作所需要的次数定义为两个字符串的距离。给定任意两个字符串，写出一个算法来计算出他们的距离。</span><br><span class="line">in:</span><br><span class="line"><span class="number">3</span></span><br><span class="line">abcdefg  abcdef</span><br><span class="line">ab ab</span><br><span class="line">mnklj jlknm</span><br><span class="line">out:</span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">数组设置：f[i][k]将字符串a的前i个字符变成字符串b的前k个字符所需要的最少操作步骤。f[<span class="number">0</span>][k]=k,f[i][<span class="number">0</span>]=i</span><br><span class="line">基本思想：相同则往前推一个，不相同则在三个方法中选取一个。</span><br><span class="line">f[i][k]=min&#123;<span class="built_in">min</span>(f[i<span class="number">-1</span>][k<span class="number">-1</span>],f[i<span class="number">-1</span>][k],f[i][k<span class="number">-1</span>])+<span class="number">1</span>,f[i<span class="number">-1</span>][k<span class="number">-1</span>]&#125;,前面是a[i]不等于b[k]，后面是a[i]等于b[k]。</span><br><span class="line">结果：f[n][m]</span><br></pre></td></tr></table></figure>

<h3 id="8-5合并石子-区间类型"><a href="#8-5合并石子-区间类型" class="headerlink" title="8.5合并石子-区间类型"></a>8.5合并石子-区间类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目描述：在一个操场上一排地摆放着Ｎ堆石子。现要将石子有次序地合并成一堆。规定每次只能选相邻的２堆石子合并成新的一堆，并将新的一堆石子数记为该次合并的得分。计算出将Ｎ堆石子合并成一堆的最小得分。</span><br><span class="line">in: <span class="number">7</span> <span class="number">13</span> <span class="number">7</span> <span class="number">8</span> <span class="number">16</span> <span class="number">21</span> <span class="number">4</span> <span class="number">18</span></span><br><span class="line">out:<span class="number">239</span></span><br><span class="line"></span><br><span class="line">数组设置：s[i]表示前i堆石头的价值总和，f[i][j]表示把第i堆到第j堆的石头合并成一堆的最优值。f[i][i]=<span class="number">0</span></span><br><span class="line">基本思想：i到j中间选择一个中介点，合并左边，合并右边，然后再合并左右两部分。</span><br><span class="line">f[i][j]=<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]+s[j]-s[i<span class="number">-1</span>])</span><br><span class="line">结果：f[<span class="number">1</span>][n]</span><br></pre></td></tr></table></figure>

<h3 id="8-6乘积最大–区间类型"><a href="#8-6乘积最大–区间类型" class="headerlink" title="8.6乘积最大–区间类型"></a>8.6乘积最大–区间类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目描述：设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+<span class="number">1</span>个部分，找出一种分法，使得这K+<span class="number">1</span>个部分的乘积能够为最大。有一个数字串：<span class="number">312</span>，当N=<span class="number">3</span>，K=<span class="number">1</span>时会有以下两种分法：(<span class="number">1</span>)<span class="number">3</span>*<span class="number">12</span>=<span class="number">36</span>，(<span class="number">2</span>)<span class="number">31</span>*<span class="number">2</span>=<span class="number">62</span>,符合题目要求的结果是：<span class="number">31</span>*<span class="number">2</span>=<span class="number">62</span>。</span><br><span class="line">in:</span><br><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">1231</span></span><br><span class="line">out:</span><br><span class="line"><span class="number">62</span></span><br><span class="line"></span><br><span class="line">数组设置：设f[i][k]表示在前i位数中插入k个乘号所得的最大值，a[j][i]表示从第j位到第i位所组成的自然数。用f[i][k]存储阶段k的每一个状态。f[j][<span class="number">0</span>]=a[<span class="number">1</span>][j] (<span class="number">1</span>&lt;j&lt;=i)。</span><br><span class="line">f[i][k]=max&#123;f[j][k<span class="number">-1</span>]*a[j+<span class="number">1</span>][i]&#125;（k&lt;=j&lt;=i）</span><br><span class="line">结果：f[n][k]</span><br></pre></td></tr></table></figure>

<h3 id="8-7乘法游戏–区间问题"><a href="#8-7乘法游戏–区间问题" class="headerlink" title="8.7乘法游戏–区间问题"></a>8.7乘法游戏–区间问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：乘法游戏是在一行牌上进行的。每一张牌包括了一个正整数。在每一个移动中，玩家拿出一张牌，得分是用它的数字乘以它左边和右边的数，所以不允许拿第<span class="number">1</span>张和最后<span class="number">1</span>张牌。最后一次移动后，这里只剩下两张牌。你的目标是使得分的和最小。</span><br><span class="line">例如，如果数是<span class="number">10</span> <span class="number">1</span> <span class="number">50</span> <span class="number">20</span> <span class="number">5</span>，依次拿<span class="number">1</span>、<span class="number">20</span>、<span class="number">50</span>，总分是                       <span class="number">10</span>*<span class="number">1</span>*<span class="number">50</span>+<span class="number">50</span>*<span class="number">20</span>*<span class="number">5</span>+<span class="number">10</span>*<span class="number">50</span>*<span class="number">5</span>=<span class="number">8000</span>，而拿<span class="number">50</span>、<span class="number">20</span>、<span class="number">1</span>，总分是<span class="number">1</span>*<span class="number">50</span>*<span class="number">20</span>+<span class="number">1</span>*<span class="number">20</span>*<span class="number">5</span>+<span class="number">10</span>*<span class="number">1</span>*<span class="number">5</span>=<span class="number">1150</span>。 </span><br><span class="line">in:</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> <span class="number">50</span> <span class="number">50</span> <span class="number">20</span> <span class="number">5</span></span><br><span class="line">out:<span class="number">3650</span></span><br><span class="line"></span><br><span class="line">数组设置：f[i][j]表示将ai~j的数全部取走(包括ai和aj)后所获得的最小得分,第<span class="number">0</span>位和第n<span class="number">-1</span>位不能取走，故f[<span class="number">1</span>][n<span class="number">-2</span>]即为所求。</span><br><span class="line">f[i][k]=<span class="built_in">min</span>(f[i][k],f[i][j<span class="number">-1</span>]+f[j+<span class="number">1</span>][k]+a[i<span class="number">-1</span>]*a[j]*a[k+<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="9-背包问题"><a href="#9-背包问题" class="headerlink" title="9.背包问题"></a>9.背包问题</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01背包：每个物品只有一个，取或不取。前i个。</span></span><br><span class="line"><span class="comment">//完全背包：每个物品有无限个。前i种。</span></span><br><span class="line"><span class="comment">//多重背包：每个物品有若干个</span></span><br><span class="line"><span class="comment">//混合背包：前三种的混合</span></span><br><span class="line"><span class="comment">//二维费用的背包：多了一个限制</span></span><br><span class="line"><span class="comment">//分组背包：同一组的物品冲突。前i组。</span></span><br><span class="line"><span class="comment">//有依赖关系的背包：省略。</span></span><br><span class="line"><span class="comment">//背包问题的方案总数：max--&gt;sum</span></span><br></pre></td></tr></table></figure>

<h3 id="9-1-01背包"><a href="#9-1-01背包" class="headerlink" title="9.1 01背包"></a>9.1 01背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">题目描述：有N件物品和一个容量为V的背包。第i件物品的费用（即体积）是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><br><span class="line">  </span><br><span class="line">特点：每种物品仅有一件，可以选择放或不放。</span><br><span class="line"></span><br><span class="line">数组设置：f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">基本思想：第i件物品选择放或者不放</span><br><span class="line">状态转移方程：f[i][v]=max&#123;f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-w[i]]+c[i]&#125;</span><br><span class="line">二维数组的解法：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)         		<span class="comment">// f[i][v]表示前i件物品，总重量不超过v的最优价值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = m; v &gt; <span class="number">0</span>; v--)</span><br><span class="line">    		<span class="keyword">if</span> (w[i] &lt;= v)  f[i][v] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][v],f[i<span class="number">-1</span>][v-w[i]]+c[i]);</span><br><span class="line">				<span class="keyword">else</span>  f[i][v] = f[i<span class="number">-1</span>][v];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n][m]);               		<span class="comment">// f[n][m]为最优解</span></span><br><span class="line">一维数组的解法，容量一定要从大到小</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt;= n; i++)              <span class="comment">//设f(v)表示重量不超过v公斤的最大价值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> v = m; v &gt;= w[i]; v--)</span><br><span class="line">    		<span class="keyword">if</span> (f[v-w[i]]+c[i]&gt;f[v])</span><br><span class="line">        		f[v] = f[v-w[i]]+c[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[m]);                      <span class="comment">// f(m)为最优解</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-2-完全背包"><a href="#9-2-完全背包" class="headerlink" title="9.2 完全背包"></a>9.2 完全背包</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 </span><br><span class="line">特点：每种物品都有无限件可用</span><br><span class="line">数组设置：f[i][v]表示前i种物品恰放入一个容量为v的背包可以获得的最大价值</span><br><span class="line">状态转移方程：f[i][v]=max&#123;f[i<span class="number">-1</span>][v-k*w[i]]+k*c[i]|<span class="number">0</span>&lt;=k*w[i]&lt;= v&#125;</span><br><span class="line">状态转移方程：f[i][v]=<span class="built_in">max</span>(f[i][v-w[i]]+c[i]，f[i<span class="number">-1</span>][v])，f[n][m]即为最优解</span><br><span class="line">容量一定是从小到大：</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N </span><br><span class="line">		<span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">				f[v]=max&#123;f[v],f[v-w[i]]+c[i]&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="9-3-多重背包问题"><a href="#9-3-多重背包问题" class="headerlink" title="9.3 多重背包问题"></a>9.3 多重背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目描述：有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是w[i]，价值是c[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><br><span class="line">特点:每种物品有多个</span><br><span class="line">思想：第i种物品有n[i]+<span class="number">1</span>种策略：取<span class="number">0</span>件，取<span class="number">1</span>件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。</span><br><span class="line">状态转移方程：f[i][v]=max&#123;f[i<span class="number">-1</span>][v-k*w[i]]+ k*c[i]|<span class="number">0</span>&lt;=k&lt;=n[i]&#125;。</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i]; k++)&#123;</span><br><span class="line">        		<span class="keyword">if</span> (j-k*v[i]&lt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            		f[j] = <span class="built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);</span><br><span class="line">           	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-混合背包问题"><a href="#9-4-混合背包问题" class="headerlink" title="9.4 混合背包问题"></a>9.4 混合背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">题目描述：如果将<span class="number">01</span>背包、完全背包、多重背包混合起来。也就是说，有的物品只可以取一次（<span class="number">01</span>背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">if</span> (p[i] == <span class="number">0</span>)&#123;                           <span class="comment">//完全背包</span></span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> j = w[i]; j &lt;= m; j++)</span><br><span class="line">      			f[j] = <span class="built_in">max</span>(f[j], f[j-w[i]]+c[i]);</span><br><span class="line">  	&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p[i]; j++)           <span class="comment">//01背包和多重背包</span></span><br><span class="line">    		<span class="keyword">for</span> (<span class="type">int</span> k = m; k &gt;= w[i]; k--)</span><br><span class="line">      			f[k] = <span class="built_in">max</span>(f[k],f[k-w[i]]+c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-二维费用的背包问题"><a href="#9-5-二维费用的背包问题" class="headerlink" title="9.5 二维费用的背包问题"></a>9.5 二维费用的背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">题目描述：二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价a和代价b，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为c[i]。</span><br><span class="line">数组设置：f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。</span><br><span class="line">状态转移方程：f[i][v][u]=max&#123;f[i<span class="number">-1</span>][v][u],f[i<span class="number">-1</span>][v-a[i]][u-b[i]]+c[i]&#125;</span><br><span class="line">相当于<span class="number">01</span>背包，也会有完全背包的情况。</span><br></pre></td></tr></table></figure>

<h3 id="9-6-分组的背包问题"><a href="#9-6-分组的背包问题" class="headerlink" title="9.6 分组的背包问题"></a>9.6 分组的背包问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目描述：有N件物品和一个容量为V的背包。第i件物品的费用是w[i]，价值是c[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</span><br><span class="line">基本思想：选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有</span><br><span class="line">f[k][v]=max&#123;f[k<span class="number">-1</span>][v]，f[k<span class="number">-1</span>][v-w[i]]+c[i]|物品i属于第k组&#125;</span><br><span class="line"><span class="keyword">for</span> 所有的组k</span><br><span class="line">		<span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">				<span class="keyword">for</span> 所有的i属于组k</span><br><span class="line">						f[v]=max&#123;f[v],f[v-w[i]]+c[i]&#125;</span><br><span class="line">注意这里的三层循环的顺序，“<span class="keyword">for</span> v=V.<span class="number">.0</span>”这一层循环必须在“<span class="keyword">for</span> 所有的i属于组k”之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="10-数论相关"><a href="#10-数论相关" class="headerlink" title="10.数论相关"></a>10.数论相关</h2><h3 id="10-1-欧几里得算法–最大公因数"><a href="#10-1-欧几里得算法–最大公因数" class="headerlink" title="10.1 欧几里得算法–最大公因数"></a>10.1 欧几里得算法–最大公因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">专门算两个数的最大公约数的算法，又称辗转相除法。即 <span class="built_in">gcd</span>(a,b) = <span class="built_in">gcd</span>(b,a%b)。很明显，边界是b = <span class="number">0</span>，返回a。</span><br><span class="line"><span class="built_in">gcd</span>(<span class="type">int</span> a,<span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-唯一分解定理"><a href="#10-2-唯一分解定理" class="headerlink" title="10.2 唯一分解定理"></a>10.2 唯一分解定理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任何一个正整数，都可以表示（分解）为所有素数（素数又叫质数，是因数只有两个的数）各种幂的积（<span class="number">1</span> = 任何素数 ^ <span class="number">0</span>，任何素数 = 自己 ^ <span class="number">1</span>），并且每个不同的数都只有一种分解，所以叫唯一分解定理。若一个数依次不被比自己小的素数整除，就可以判断它是素数。两个数的最大公约数就是这两个数的唯一分解式中重合的因子的积。一对互质数的分解中是没有重复的。</span><br><span class="line"></span><br><span class="line">如 <span class="number">36</span> = <span class="number">2</span> ^ <span class="number">2</span> * <span class="number">3</span> ^ <span class="number">2</span> ( <span class="number">2</span> * <span class="number">2</span> * <span class="number">3</span> * <span class="number">3</span> ),   <span class="number">10</span> = <span class="number">2</span> * <span class="number">5</span>。</span><br></pre></td></tr></table></figure>

<h3 id="10-3-埃氏筛"><a href="#10-3-埃氏筛" class="headerlink" title="10.3 埃氏筛"></a>10.3 埃氏筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">题目描述：想要知道小于等于n有多少个素数</span><br><span class="line">基本思想：对于任意一个大于 <span class="number">1</span> 的正整数 n，那么它的 x 倍就是合数（x &gt; <span class="number">1</span>）。利用这个结论，我们可以避免很多次不必要的检测。如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数。时间复杂度是 <span class="built_in">O</span>(<span class="built_in">n</span>(<span class="built_in">log</span>(logn)))。</span><br><span class="line">  </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="type">bool</span> is_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eratosthenes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  is_prime[<span class="number">0</span>] = is_prime[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) is_prime[i] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_prime[i]) &#123;</span><br><span class="line">      prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)i * i &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i * i; j &lt;= n; j += i)</span><br><span class="line">        <span class="comment">// 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i</span></span><br><span class="line">        <span class="comment">// 的倍数开始，提高了运行速度</span></span><br><span class="line">        is_prime[j] = <span class="literal">false</span>;  <span class="comment">// 是 i 的倍数的均不是素数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="10-4-线性筛"><a href="#10-4-线性筛" class="headerlink" title="10.4 线性筛"></a>10.4 线性筛</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。如果能让每个合数都只被标记一次，那么时间复杂度就可以降到<span class="built_in">O</span>(n)了。线性筛法 也称为 Euler 筛法（欧拉筛法）</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!not_prime[i]) &#123;</span><br><span class="line">      pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> pri_j : pri) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i * pri_j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">      not_prime[i * pri_j] = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (i % pri_j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// i % pri_j == 0</span></span><br><span class="line">        <span class="comment">// 换言之，i 之前被 pri_j 筛过了</span></span><br><span class="line">        <span class="comment">// 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被</span></span><br><span class="line">        <span class="comment">// pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break</span></span><br><span class="line">        <span class="comment">// 掉就好了</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pri[N+<span class="number">9</span>&gt;&gt;<span class="number">1</span>],now;</span><br><span class="line"><span class="type">bool</span> vis[N+<span class="number">9</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])pri[++now]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=now&amp;&amp;pri[j]*i&lt;=N;j++)&#123;</span><br><span class="line">            vis[pri[j]*i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Dikstra"><a href="#Dikstra" class="headerlink" title="Dikstra"></a>Dikstra</h2><h2 id="Belman-Ford。"><a href="#Belman-Ford。" class="headerlink" title="Belman-Ford。"></a>Belman-Ford。</h2><h2 id="Spfa单源次短路"><a href="#Spfa单源次短路" class="headerlink" title="Spfa单源次短路"></a>Spfa单源次短路</h2><h2 id="Floyd求任意两点最短路和传递闭包"><a href="#Floyd求任意两点最短路和传递闭包" class="headerlink" title="Floyd求任意两点最短路和传递闭包;"></a>Floyd求任意两点最短路和传递闭包;</h2><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集;"></a>并查集;</h2><h2 id="最小生成树-prim，kruskal"><a href="#最小生成树-prim，kruskal" class="headerlink" title="最小生成树: prim，kruskal;"></a>最小生成树: prim，kruskal;</h2><h2 id="树的三种遍历"><a href="#树的三种遍历" class="headerlink" title="树的三种遍历;"></a>树的三种遍历;</h2><h2 id="RMQ问题"><a href="#RMQ问题" class="headerlink" title="RMQ问题:"></a>RMQ问题:</h2><h2 id="ST算法，"><a href="#ST算法，" class="headerlink" title="ST算法，"></a>ST算法，</h2><h2 id="树状数组。"><a href="#树状数组。" class="headerlink" title="树状数组。"></a>树状数组。</h2><h2 id="树与二叉树的转化、"><a href="#树与二叉树的转化、" class="headerlink" title="树与二叉树的转化、"></a>树与二叉树的转化、</h2><h2 id="树的最长链，最近公共祖先-欧拉道路和欧拉回路-二分图及相关算法"><a href="#树的最长链，最近公共祖先-欧拉道路和欧拉回路-二分图及相关算法" class="headerlink" title="树的最长链，最近公共祖先;欧拉道路和欧拉回路;二分图及相关算法;"></a>树的最长链，最近公共祖先;欧拉道路和欧拉回路;二分图及相关算法;</h2><h2 id="求强连通分量，强连通分量的缩点算法，求割边和割点-树形DP-数论进阶-同余式，逆元，中国剩余定理，扩展欧几里得"><a href="#求强连通分量，强连通分量的缩点算法，求割边和割点-树形DP-数论进阶-同余式，逆元，中国剩余定理，扩展欧几里得" class="headerlink" title="求强连通分量，强连通分量的缩点算法，求割边和割点;树形DP;数论进阶:同余式，逆元，中国剩余定理，扩展欧几里得"></a>求强连通分量，强连通分量的缩点算法，求割边和割点;树形DP;数论进阶:同余式，逆元，中国剩余定理，扩展欧几里得</h2><h2 id="高级动态规划与高级数据结构专题-斜率优化，状态压缩-字符串专题-KMP算法，Manacher算法，Trie树数据结构-线段树，平衡树"><a href="#高级动态规划与高级数据结构专题-斜率优化，状态压缩-字符串专题-KMP算法，Manacher算法，Trie树数据结构-线段树，平衡树" class="headerlink" title="高级动态规划与高级数据结构专题:斜率优化，状态压缩;字符串专题:KMP算法，Manacher算法，Trie树数据结构:线段树，平衡树"></a>高级动态规划与高级数据结构专题:斜率优化，状态压缩;字符串专题:KMP算法，Manacher算法，Trie树数据结构:线段树，平衡树</h2><h2 id="网络端管法-动太村二维线段城块状链走-树等之4AC白动机才展KP、复杂动态规划点型的核律利什"><a href="#网络端管法-动太村二维线段城块状链走-树等之4AC白动机才展KP、复杂动态规划点型的核律利什" class="headerlink" title="网络端管法 动太村二维线段城块状链走:树等之4AC白动机才展KP、复杂动态规划点型的核律利什"></a>网络端管法 动太村二维线段城块状链走:树等之4AC白动机才展KP、复杂动态规划点型的核律利什</h2>
  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://ShaolongTang.github.io/shaolongtang" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 John Doe</li>
      <li><a href="http://ShaolongTang.github.io/shaolongtang">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a target="_blank" rel="noopener" href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a target="_blank" rel="noopener" href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/shaolongtang/js/main.js"></script>

</body>
</html>
